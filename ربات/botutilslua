+ tdcli = dofile ( ' ./tg/tdcli.lua ' )+ serpent = ( loadfile " ./libs/serpent.lua " ) ()+ feedparser = ( loadfile " ./libs/feedparser.lua " ) ()+ require ( ' ./bot/utils ' )+ URL = require " socket.url "+ http = نیاز به " socket.http "+ https = require " ssl.https "+ ltn12 = نیاز به " ltn12 "+ json = ( loadfile " ./libs/JSON.lua " ) ()+ mimetype = ( loadfile " ./libs/mimetype.lua " ) ()+ redis = ( loadfile " ./libs/redis.lua " ) ()+ JSON = ( loadfile " ./libs/dkjson.lua " ) ()+ محلی lgi = require ( ' lgi ' )+ local notify = lgi. درخواست ( ' اطلاع ' )+ اطلاع دهید init ( " Telegram به روزرسانی " )+ chats = {}+ helper_id = 418516842 - قرار دادن Helper Bot ID در اینجا++ function do_notify ( کاربر ، msg )+	 محلی n = اطلاع هشدار از طریق . جدید (کاربر، پیام)+ n: نمایش ()+ پایان++ تابع dl_cb ( arg ، data )+	 - نام کاربری (اطلاعات)+ پایان+ تابع نامحدود ( مقدار )+	 چاپ (مارک بلوک (ارزش، {comment = false }))+ پایان+ function load_data ( نام فایل )+	 محلی f = io.open (نام فایل)+	 اگر نه f سپس+		 بازگشت {}+	 پایان+	 محلی s = f: خواندن ( ' * همه ' )+ f: close ()+	 داده های محلی = JSON. رمزگشایی (ها)+	 اطلاعات بازگشت+ پایان++ function save_data ( نام فایل ، داده )+	 محلی s = JSON رمزگذاری (داده ها)+	 محلی f = io.open (نام فایل، ' w ' )+ f: نوشتن (ها)+ f: close ()+ پایان++ تابع match_plugins ( msg )+	 برای نام، پلاگین در جفت (پلاگین) انجام دهید+		 match_plugin (پلاگین، نام، پیام)+	 پایان+ پایان++ - اعمال تابع plugin.pre_process+ عملکرد pre_process_msg ( msg )+ برای نام، پلاگین در جفت (پلاگین) انجام دهید+ اگر پلاگین pre_process و msg پس از آن+ چاپ ( ' پیش پردازش ' ، نام)+ نتیجه = پلاگین pre_process (msg)+ پایان+ پایان+ بازگشت نتیجه+ پایان++ تابع save_config ()+	 serialize_to_file (_config، ' ./data/config.lua ' )+	 print ( ' پیکربندی ذخیره شده در ./data/config.lua ' )+ پایان++ تابع کایامی ()+	 محلی USR = io.popen ( " از whoami " ): به عنوان خوانده شده ( : * یک : )+ usr = string.gsub (usr، ' ^٪ s + ' ، ' ' )+ usr = string.gsub (usr، ' ٪ s + $ ' ، ' ' )+ usr = string.gsub (usr، ' [ \ n \ r ] + ' ، ' ' )+	 اگر usr: match ( " ^ root $ " ) سپس+ tcpath = ' /root/.telegram-cli '+	 ELSEIF نمی USR: بازی ( " ^ ریشه $ " ) پس از آن+ tcpath = ' / home / ' .. usr .. ' /.telegram-cli '+	 پایان+ print ( ' >> Download Path = ' .. tcpath)+ پایان++ function create_config ()+ - پیکربندی ساده با پلاگین های اولیه و خودمان به عنوان کاربر مهمان+ config = {+ enabled_plugins = {+ " BanHammer " ،+ " سرگرم کننده " ،	+ " GroupManager " ،+ " MSG-چک " ،	+ " پلاگین " ،+ " ابزارهای " ،+ " نوشتن "+}+ sudo_users = { 377450049 ، 418516842 ، 284298227 }،+ admins = {}+ disabled_channels = {}+ moderation = {data = ' ./data/moderation.json ' }،+ info_text = [[+ 	"MaTaDoR BoT v5.7+ یک ربات مدیریت پیشرفته بر اساس https://valtman.name/telegram-cli++ "https://github.com/BeyondTeam/BDReborn++ "مدیران:+ "MahDiRoO ➣ سازنده و توسعهدهنده"+ "JavadSudo ➣ برنامه نویس"+ "Shaniloop Developer Developer"++ "تشکر ویژه به:+ "MaTaDoRTeaM+ "@ Xamarin_Devloper."++ "کانال ما:+ "MaTaDoRTeam"+ ]] ،+}+	 serialize_to_file (config، ' ./data/config.lua ' )+	 print ( ' پیکربندی ذخیره شده در conf.lua ' )+ پایان++ - پیکربندی را از فایل config.lua باز می گرداند.+ - اگر فایل وجود ندارد، آن را ایجاد کنید.+ function load_config ()+	 محلی F = io.open ( ، ./data/config.lua ، ، " R " )+ - اگر config.lua وجود ندارد+	 اگر نه f سپس+		 print ( " ایجاد فایل پیکربندی جدید: ./data/config.lua " )+		 create_config ()+	 دیگر+ f: close ()+	 پایان+	 local config = loadfile ( " ./data/config.lua " ) ()+	 برای v، کاربر در جفت (config. sudo_users ) انجام می شود+		 چاپ ( " مجاز کاربر: " .. کاربر)+	 پایان+	 config بازگشت+ پایان+ کایامی ()+ plugins = {}+ _config = load_config ()++ function load_plugins ()+	 local config = loadfile ( " ./data/config.lua " ) ()+	 برای k، v در جفت (config. enabled_plugins ) انجام دهید+		 چاپ ( " بارگیری پلاگین " ، v)+		 محلی ok، err = pcall ( function ()+		 محلی t = loadfile ( " plugins / " .. v .. ' .lua ' ) ()+ پلاگین [v] = t+		 پایان )+		 اگر خوب نیست پس+			 print ( ' \ 27 [31mError loading plugins ' .. v .. ' \ 27 [39m ' ]+			: به عنوان خوانده شده ( : * همه ، )))+			 چاپ ( ' \ 27 [31m ' .. اشتباه .. ' \ 27 [39m ' ]+		 پایان+	 پایان+ پایان++ عملکرد msg_valid ( msg )+	 اگر MSG. date_ < os.time () - 60 بعد+ print ( ' \ 27 [36mNot معتبر: old msg ' 27 [39m ' ]+		 بازگشت نادرست+	 پایان+ if is_silent_user (msg. sender_user_id_ ، msg. chat_id_ ) سپس+ del_msg (msg. chat_id_ ، msg. id_ )+ بازگشت نادرست+ پایان+ if is_banned (msg. sender_user_id_ ، msg. chat_id_ ) سپس+ del_msg (msg. chat_id_ ، tonumber (msg. id_ ))+ kick_user (msg. sender_user_id_ ، msg. chat_id_ )+ بازگشت نادرست+ پایان+ if is_gbanned (msg. sender_user_id_ ) سپس+ del_msg (msg. chat_id_ ، tonumber (msg. id_ ))+ kick_user (msg. sender_user_id_ ، msg. chat_id_ )+ بازگشت نادرست+ پایان+ بازگشت درست+ پایان++ تابع match_pattern ( الگوی ، متن ، lower_case )+	 اگر متن پس از آن+		 محلی مسابقات = {}+ در		 صورت lower_case سپس+ matches = { string.match (text: lower ()، pattern}}+		 دیگر+ match = { string.match (متن، الگوی)}+		 پایان+		 اگر بعدی (مسابقات) سپس+			 بازگشت بازی+		 پایان+	 پایان+ پایان++ - بررسی کنید که آیا پلاگین در جدول _config.disabled_plugin_on_chat است+ تابع محلی is_plugin_disabled_on_chat (نام پلاگین ، گیرنده )+ محلی disabled_chats = _config. disabled_plugin_on_chat+ - جدول وجود دارد و گپ افزونه ها را غیر فعال کرده است+ اگر disabled_chats و disabled_chats [گیرنده] پس از آن باشد+ - بررسی می کند که آیا افزونه در این چت غیرفعال است+ برای disabled_plugin، غیر فعال در جفت (disabled_chats [گیرنده]) انجام دهید+ if disabled_plugin == plugin_name و پس از آن غیر فعال شده است+ local warning = ' _Plugin_ * ' .. check_markdown (disabled_plugin) .. ' * این در این چت_ غیرفعال است '+ چاپ (هشدار)+ tdcli sendMessage (گیرنده، " " ، 0 ، هشدار، 0 ، " md " )+ بازگشت درست چاپ ( متد toString ( io.popen ( " LUA پلاگین ها / " .. V .. " .lua " )
